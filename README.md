# algorithm-problems
Algorithm Problems with Solutions

1. 2-3 pointers
2. binary search - classic problem: –ï—Å—Ç—å —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤ —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª arr, –Ω—É–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å, –µ—Å—Ç—å –ª–∏ –≤ –Ω—ë–º —á–∏—Å–ª–æ X.
–í –æ–±—â–µ–º –∏ —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª –ø–æ–∏—Å–∫–∞ –Ω–∞ –∫–∞–∂–¥–æ–º —à–∞–≥–µ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –±—É–¥–µ—Ç —Å–æ–∫—Ä–∞—â–∞—Ç—å—Å—è –≤ –¥–≤–∞ —Ä–∞–∑–∞. –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ –æ–Ω —Ä–∞–≤–µ–Ω ùëÅ N, 
–ø–æ—Å–ª–µ –æ–¥–Ω–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏ –æ–Ω –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å ùëÅ / 2 N/2 —ç–ª–µ–º–µ–Ω—Ç–æ–≤, –∑–∞—Ç–µ–º ùëÅ / 4 N/4, –Ω–∞ ùëò k-–π –∏—Ç–µ—Ä–∞—Ü–∏–∏ –≤ –Ω—ë–º –±—É–¥–µ—Ç ùëÅ / 2 ùëò N/2 k —ç–ª–µ–º–µ–Ω—Ç–æ–≤. 
–ö–∞–∫ —Ç–æ–ª—å–∫–æ 2 ùëò 2 k —Å—Ç–∞–Ω–µ—Ç –±–æ–ª—å—à–µ ùëÅ N, –∞–ª–≥–æ—Ä–∏—Ç–º –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è.
–ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∑–∞–¥–∞—á–∏ —Ñ–æ—Ä–º–∞–ª—å–Ω–æ –Ω–µ —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è—é—Ç —É—Å–ª–æ–≤–∏—é –º–æ–Ω–æ—Ç–æ–Ω–Ω–æ—Å—Ç–∏ –∏, —Ç–µ–º –Ω–µ –º–µ–Ω–µ–µ, —Ä–µ—à–∞—é—Ç—Å—è –±–∏–Ω–∞—Ä–Ω—ã–º –ø–æ–∏—Å–∫–æ–º (see src/main/java/org/example/algo/practicum/yandex/, binary_search_3).
3. Fibonachi
4. –í —Ä–µ–∞–ª—å–Ω–æ–π –∂–∏–∑–Ω–∏ —Ä–µ–∫—É—Ä—Å–∏—é –æ—á–µ–Ω—å —É–¥–æ–±–Ω–æ –ø—Ä–∏–º–µ–Ω—è—Ç—å –¥–ª—è –æ–±—Ö–æ–¥–∞ –≥—Ä–∞—Ñ–æ–≤ –∏–ª–∏ –¥–µ—Ä–µ–≤—å–µ–≤ ‚Äî —Ç–∞–∫–∏—Ö –∫–∞–∫ —Ñ–∞–π–ª–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞. –ú–µ—Ç–æ–¥ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è ¬´–ø–æ–∏—Å–∫ –≤ –≥–ª—É–±–∏–Ω—É¬ª.
Dynamic prog
5. –±—ã–≤–∞–µ—Ç —É–¥–æ–±–Ω–æ —Ä–∞–±–æ—Ç–∞—Ç—å —Å —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏. –ö–∞–∫ –ø—Ä–∞–≤–∏–ª–æ, —É—Å–ª–æ–≤–∏—è –∑–∞–¥–∞—á–∏ –Ω–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É—é—Ç, —á—Ç–æ –¥–∞–Ω–Ω—ã–µ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã. 
–ü–æ—ç—Ç–æ–º—É –ø—Ä–∏ —Ä–µ—à–µ–Ω–∏–∏ –Ω—É–∂–Ω–æ –ø–æ–Ω—è—Ç—å, —á—Ç–æ —Ç—Ä–µ–±—É–µ—Ç—Å—è —Å–Ω–∞—á–∞–ª–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ, –∞ –∑–∞—Ç–µ–º –ø—Ä–∏–º–µ–Ω–∏—Ç—å –æ–¥–∏–Ω –∏–∑ —É–∫–∞–∑–∞–Ω–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤.
6. –¥–µ—Ä–µ–≤—å—è ‚Äî —á–∞—Å—Ç–Ω—ã–π —Å–ª—É—á–∞–π –≥—Ä–∞—Ñ–æ–≤
7. Trie data structure: https://www.geeksforgeeks.org/trie-insert-and-search/
8. We use Queue for BFS and Stack for DFS. In the first round, we process the root node. In the second round, we 
poll (returns and removes the element) the root and process the nodes next to the root node. In the third round, we 
process the nodes which are two steps from the root node, e.i poll from to find the nodes next to it. So on and so forth.
It is important to make sure that we never visit a node twice. Otherwise, we might get stuck in an infinite loop, e.g. in graph with cycle.
So we can keep a hashSet to store the visited nodes. Or we can use a boolean array to store the visited nodes.
9. Depth-First Search (DFS) can also be used to find the path from the root node to the target node. We start from the root node A. 
Firstly, we choose the path to the node B and trace-back till we reach the end where we have no way to go deeper. Then we
backtrack to A and choose the second path to the node C. We repeat the process until we find the target node. 
10. In most cases, we can also use DFS when using BFS. But there is an important difference: the traversal order. 
Different from BFS, the nodes you visit earlier might not be the nodes which are closer to the root node. As a result, 
the first path you found in DFS might not be the shortest path.
11. 