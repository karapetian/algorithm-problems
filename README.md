# algorithm-problems
Algorithm Problems with Solutions

1. 2-3 pointers: —Å –¥–≤—É—Ö —Å—Ç–æ—Ä–æ–Ω; –ö–∞–∂–¥–æ–º—É –º–∞—Å—Å–∏–≤—É –ø–æ —É–∫–∞–∑–∞—Ç–µ–ª—é; –ú–µ–¥–ª–µ–Ω—ã–π –∏ –±—ã—Å—Ç—Ä—ã–π —É–∫–∞–∑–∞—Ç–µ–ª–∏(–ø–æ–º–µ–Ω—è—Ç—å –º–µ—Å—Ç–∞–º–∏ –∏–ª–∏ —Å—Ä–∞–≤–Ω–∏—Ç—å)
2. binary search - classic problem: –ï—Å—Ç—å —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤ —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª arr, –Ω—É–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å, –µ—Å—Ç—å –ª–∏ –≤ –Ω—ë–º —á–∏—Å–ª–æ X.
–í –æ–±—â–µ–º –∏ —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª –ø–æ–∏—Å–∫–∞ –Ω–∞ –∫–∞–∂–¥–æ–º —à–∞–≥–µ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –±—É–¥–µ—Ç —Å–æ–∫—Ä–∞—â–∞—Ç—å—Å—è –≤ –¥–≤–∞ —Ä–∞–∑–∞. –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ –æ–Ω —Ä–∞–≤–µ–Ω ùëÅ, 
–ø–æ—Å–ª–µ –æ–¥–Ω–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏ –æ–Ω –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å N/2 —ç–ª–µ–º–µ–Ω—Ç–æ–≤, –∑–∞—Ç–µ–º N/4, –Ω–∞ ùëò k-–π –∏—Ç–µ—Ä–∞—Ü–∏–∏ –≤ –Ω—ë–º –±—É–¥–µ—Ç N/2k —ç–ª–µ–º–µ–Ω—Ç–æ–≤. 
–ö–∞–∫ —Ç–æ–ª—å–∫–æ 2 ùëò —Å—Ç–∞–Ω–µ—Ç –±–æ–ª—å—à–µ ùëÅ, –∞–ª–≥–æ—Ä–∏—Ç–º –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è.
–ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∑–∞–¥–∞—á–∏ —Ñ–æ—Ä–º–∞–ª—å–Ω–æ –Ω–µ —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è—é—Ç —É—Å–ª–æ–≤–∏—é –º–æ–Ω–æ—Ç–æ–Ω–Ω–æ—Å—Ç–∏ –∏, —Ç–µ–º –Ω–µ –º–µ–Ω–µ–µ, —Ä–µ—à–∞—é—Ç—Å—è –±–∏–Ω–∞—Ä–Ω—ã–º –ø–æ–∏—Å–∫–æ–º (see src/main/java/org/example/algo/practicum/yandex/, binary_search_3).
   https://kinescope.io/hMQRNHaRWXkvkEVM2GSj3c
   –ë–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫ –º–æ–∂–Ω–æ –ø—Ä–∏–º–µ–Ω–∏—Ç—å, –µ—Å–ª–∏ –º–æ–∂–µ–º —Ä–∞–∑–¥–µ–ª–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –Ω–∞ —Ö–æ—Ä–æ—à–∏–µ –∏ –ø–ª–æ—Ö–∏–µ, –ø—Ä–∏ —ç—Ç–æ–º —Å–Ω–∞—á–∞–ª–∞ –∏–¥—É—Ç –≤—Å–µ "—Ö–æ—Ä–æ—à–∏–µ", 
–∞ –ø–æ—Ç–æ–º –≤—Å–µ "–ø–ª–æ—Ö–∏–µ". –ì–ª–∞–≤–Ω–∞—è –∑–∞–¥–∞—á–∞ –±–∏–Ω. –ø–æ–∏—Å–∫–∞: –Ω–∞–π—Ç–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ö–æ—Ä–æ—à–∏–π –∏ –ø–µ—Ä–≤—ã–π –ø–ª–æ—Ö–æ–π!
–ü–ê–¢–¢–ï–†–ù –ë–ò–ù–ê–†–ù–´–ô –ü–û–ò–°–ö:
   #01 –î–ª—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –ø—Ä–∏–º–µ—Ä–æ–≤ –≤—ã–±—Ä–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç, –∫–æ—Ç–æ—Ä—ã–π –º—ã –±—É–¥–µ–º –∏—Å–∫–∞—Ç—å
   #02 –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –≤ –∫–∞–∫–æ–º —É–∫–∞–∑–∞—Ç–µ–ª–µ –æ—Ç–≤–µ—Ç (–ª–µ–≤—ã–π –∏–ª–∏ –ø—Ä–∞–≤—ã–π) + –Ω–∞—á–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é —É–∫–∞–∑–∞—Ç–µ–ª–µ–π
   #03 –ü—Ä–∏–¥—É–º–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é good, –∫–æ—Ç–æ—Ä–∞—è –ø–æ–¥–æ–π–¥–µ—Ç –¥–ª—è –≤—Å–µ—Ö –ø—Ä–∏–º–µ—Ä–æ–≤. In good function you can only have the target, array and middle value
3. Fibonachi
4. –í —Ä–µ–∞–ª—å–Ω–æ–π –∂–∏–∑–Ω–∏ —Ä–µ–∫—É—Ä—Å–∏—é –æ—á–µ–Ω—å —É–¥–æ–±–Ω–æ –ø—Ä–∏–º–µ–Ω—è—Ç—å –¥–ª—è –æ–±—Ö–æ–¥–∞ –≥—Ä–∞—Ñ–æ–≤ –∏–ª–∏ –¥–µ—Ä–µ–≤—å–µ–≤ ‚Äî —Ç–∞–∫–∏—Ö –∫–∞–∫ —Ñ–∞–π–ª–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞. –ú–µ—Ç–æ–¥ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è ¬´–ø–æ–∏—Å–∫ –≤ –≥–ª—É–±–∏–Ω—É¬ª.
Dynamic prog
5. –±—ã–≤–∞–µ—Ç —É–¥–æ–±–Ω–æ —Ä–∞–±–æ—Ç–∞—Ç—å —Å —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏. –ö–∞–∫ –ø—Ä–∞–≤–∏–ª–æ, —É—Å–ª–æ–≤–∏—è –∑–∞–¥–∞—á–∏ –Ω–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É—é—Ç, —á—Ç–æ –¥–∞–Ω–Ω—ã–µ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã. 
–ü–æ—ç—Ç–æ–º—É –ø—Ä–∏ —Ä–µ—à–µ–Ω–∏–∏ –Ω—É–∂–Ω–æ –ø–æ–Ω—è—Ç—å, —á—Ç–æ —Ç—Ä–µ–±—É–µ—Ç—Å—è —Å–Ω–∞—á–∞–ª–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ, –∞ –∑–∞—Ç–µ–º –ø—Ä–∏–º–µ–Ω–∏—Ç—å –æ–¥–∏–Ω –∏–∑ —É–∫–∞–∑–∞–Ω–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤.
6. –¥–µ—Ä–µ–≤—å—è ‚Äî —á–∞—Å—Ç–Ω—ã–π —Å–ª—É—á–∞–π –≥—Ä–∞—Ñ–æ–≤
7. Trie data structure: https://www.geeksforgeeks.org/trie-insert-and-search/
8. We use **Queue for BFS** and **Stack for DFS**. In the first round, we process the root node. In the second round, we 
poll (returns and removes the element) the root and process the nodes next to the root node. In the third round, we 
process the nodes which are two steps from the root node, e.i poll from to find the nodes next to it. So on and so forth.
It is important to make sure that we never visit a node twice. Otherwise, we might get stuck in an infinite loop, e.g. in graph with cycle.
So we can keep a hashSet to store the visited nodes. Or we can use a boolean array to store the visited nodes.
9. Depth-First Search (DFS) can also be used to find the path from the root node to the target node. We start from the root node A. 
Firstly, we choose the path to the node B and trace-back till we reach the end where we have no way to go deeper. Then we
backtrack to A and choose the second path to the node C. We repeat the process until we find the target node. 
10. In most cases, we can also use DFS when using BFS. But there is an important difference: the traversal order. 
Different from BFS, the nodes you visit earlier might not be the nodes which are closer to the root node. As a result, 
the first path you found in DFS might not be the shortest path.
11. Counting Sort - Time O(n+k) and Space O(n+k); efficient when the range of input values is small compared to the number
of elements to be sorted. The basic idea behind Counting Sort is to count the frequency of each distinct element in the 
input array and use that information to place the elements in their correct sorted positions. The Range should be smaller
than the number of elements
12. https://almond-city-dee.notion.site/195f64241af0809bb6f9f76b85c328e1
    https://www.youtube.com/watch?v=6h-blOjL43s
13. HEAP (Priority Queue)- Kth largest element; top K frequent element. A heap is a special kind of binary tree.
It's a **complete binary tree** (every level is completely filled except possibly the last, which is filled from left to right).
In a min heap the parent node is always less than or equal to its children. The smallest element is at the root.
In a max heap the parent node is always greater than or equal to its children. The largest element is at the root.
For Insert add the new element at the end (last level, next open spot). Then "heapify up" to restore the heap property.
For delete (usually the root) replace the root with the last element. Then "heapify down" to restore the heap property.
https://www.youtube.com/watch?v=VEYSSANa-cw
15. HashTable - Anagrams
16. Sorting - use O(n2) only when you have O(1) place complexity
17. BST (Binary Search Tree) - the right part nodes are bigger than the root, and the left nodes are smaller.
Recursively look at the left part, add them into the results. Recursively look at the left part, and go back to the Root.
https://www.youtube.com/watch?v=8K7EO7s_iFE
18. You have a large file (32 GB) where each line contains a single word. The machine has only 4 GB of operational memory (RAM).
Sort the words in the file in ascending order.
Solution: Split the 32 GB file into smaller chunks that fit into memory (e.g., 8 chunks of ~4 GB each).
Read each chunk into memory, sort the words using an efficient algorithm (like quicksort or mergesort), and write the sorted words back to temporary files.
Merge: Use a **min-heap** to merge the sorted chunks: Open all sorted chunk files. Initialize the heap with the first word from each file.
Repeatedly extract the smallest word from the heap, write it to the final output, and replenish the heap with the next word from the corresponding file.
Continue until all words from all chunks are processed.

https://www.linkedin.com/posts/ankitapy_dsa-leetcode-interview-activity-7298578598326677504-iL9e?utm_source=social_share_send&utm_medium=member_desktop_web&rcm=ACoAAC5CJqwBXQwpcP8dFhZwCWAJx3-8YrTh96I
https://leetcode.com/discuss/post/449135/how-to-effectively-use-leetcode-to-prepa-m7gt/
https://leetcode.com/discuss/post/494279/comprehensive-data-structure-and-algorit-tdez/

19. int mid = startPos + (endPos - startPos) / 2;